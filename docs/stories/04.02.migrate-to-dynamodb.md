# Story 04.02: Migrate Data Layer from MongoDB to DynamoDB using ElectroDB

## Context

Currently, the application uses MongoDB as its database with Mongoose ODM. To better align with AWS infrastructure and improve scalability, we need to migrate to DynamoDB using ElectroDB as the data modeling library.

## Current Implementation

The application currently uses:

- MongoDB with Mongoose ODM
- Repository pattern implementation in `libs/dal`
- Four main collections: users, seatConfigurations, daySeatOverrides, and bookings
- Data access through TypeScript interfaces defined in `libs/types`

## Requirements

### Functional Requirements

1. Migrate existing MongoDB schema to DynamoDB with ElectroDB models
2. Maintain existing repository interfaces and patterns
3. Ensure all current queries and data operations work as before
4. Support atomic operations for booking management
5. Implement efficient querying patterns for date-based lookups

### Technical Requirements

1. Set up DynamoDB table design following single-table pattern
2. Implement ElectroDB models for all entities
3. Update repository implementations to use ElectroDB
4. Maintain TypeScript type safety
5. Handle data migration from MongoDB to DynamoDB
6. Update infrastructure code for DynamoDB provisioning

## Acceptance Criteria

### 1. DynamoDB Table Design

- [ ] Design single-table schema that supports all current access patterns
- [ ] Define appropriate partition and sort keys for each entity
- [ ] Document the access patterns and their implementations

### 2. ElectroDB Model Implementation

- [ ] Create ElectroDB models for all entities:
  - [ ] User model
  - [ ] SeatConfiguration model
  - [ ] DaySeatOverride model
  - [ ] Booking model
- [ ] Implement all required indexes
- [ ] Add TypeScript types for the models

### 3. Repository Layer Updates

- [ ] Update repository implementations while maintaining current interfaces:
  - [ ] UserRepository
  - [ ] BookingRepository
  - [ ] SeatConfigurationRepository
  - [ ] DaySeatOverrideRepository
- [ ] Implement all current query patterns using ElectroDB
- [ ] Add unit tests for the new implementations

### 4. Infrastructure Updates

- [ ] Add DynamoDB table definition in CDK
- [ ] Configure appropriate capacity settings
- [ ] Set up backup strategy
- [ ] Update environment variables and configuration

### 5. Migration Strategy

- [ ] Create data migration script
- [ ] Test migration process
- [ ] Plan for zero-downtime migration
- [ ] Include rollback strategy

## Technical Notes

### DynamoDB Table Design

```typescript
// Example composite key structure
{
  PK: "USER#${azureAdId}",
  SK: "PROFILE#${azureAdId}",
  GSI1PK: "BOOKINGS#${date}",
  GSI1SK: "USER#${azureAdId}",
  // ... other attributes
}
```

### Access Patterns to Support

1. Get user by Azure AD ID
2. Get all bookings for a date
3. Get user's bookings for a date range
4. Get seat configuration and overrides
5. Atomic booking creation with capacity check

### Implementation Steps

1. Initial setup of ElectroDB and DynamoDB infrastructure
2. Model implementation following the single-table design
3. Repository layer refactoring
4. Migration script development
5. Testing and validation
6. Deployment and migration execution

## Dependencies

- ElectroDB library
- AWS DynamoDB
- AWS CDK for infrastructure
- Existing TypeScript interfaces in `libs/types`

## Risks and Mitigations

1. **Risk**: Data loss during migration  
   **Mitigation**: Thorough testing and backup strategy

2. **Risk**: Performance impact  
   **Mitigation**: Proper DynamoDB capacity planning and testing

3. **Risk**: Query pattern incompatibilities  
   **Mitigation**: Early proof of concept for complex queries

4. **Risk**: Deployment issues  
   **Mitigation**: Detailed rollback plan and staged deployment

## Test Plan

1. Unit tests for all repository methods
2. Integration tests for complex queries
3. Load testing for common access patterns
4. Migration script testing with production-like data
5. Rollback procedure testing

## Definition of Done

- [ ] All acceptance criteria met
- [ ] Documentation updated
- [ ] Tests passing
- [ ] Migration script tested
- [ ] Zero-downtime deployment plan verified
- [ ] Performance testing completed
- [ ] Code review completed
